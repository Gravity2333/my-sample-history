/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./src/libs/EventCenter.ts":
/*!*********************************!*\
  !*** ./src/libs/EventCenter.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * 实现一个事件中心，用来存储history变动处理函数，Block处理函数\n *\n */\nclass EventCenter {\n    events = [];\n    /** 获取事件数量 */\n    get length() {\n        return this.events.length;\n    }\n    /** 监听函数 */\n    listen(event) {\n        this.events.push(event);\n        return () => {\n            this.events = this.events.filter(e => e !== event);\n        };\n    }\n    /** call函数 触发事件 */\n    call(arg) {\n        this.events.forEach(fn => fn && fn(arg));\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventCenter);\n\n\n//# sourceURL=webpack://my-sample-history/./src/libs/EventCenter.ts?");

/***/ }),

/***/ "./src/libs/generateUniqueKey.ts":
/*!***************************************!*\
  !*** ./src/libs/generateUniqueKey.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ generateUniqueKey)\n/* harmony export */ });\nfunction generateUniqueKey(length = 8) {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let id = '';\n    for (let i = 0; i < length; i++) {\n        id += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return id;\n}\n\n\n//# sourceURL=webpack://my-sample-history/./src/libs/generateUniqueKey.ts?");

/***/ }),

/***/ "./src/libs/index.ts":
/*!***************************!*\
  !*** ./src/libs/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory)\n/* harmony export */ });\n/* harmony import */ var _EventCenter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EventCenter */ \"./src/libs/EventCenter.ts\");\n/* harmony import */ var _generateUniqueKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generateUniqueKey */ \"./src/libs/generateUniqueKey.ts\");\n\n\nvar Action;\n(function (Action) {\n    // 历史变动 不分方向 默认\n    Action[\"POP\"] = \"POP\";\n    // 新增动作\n    Action[\"PUSH\"] = \"PUSH\";\n    // 替换动作\n    Action[\"REPLACE\"] = \"REPLACE\";\n})(Action || (Action = {}));\n/** hash变动事件名称 */\nconst ON_HASH_CHANGE = \"onhashchange\";\n/** popstate事件名称 */\nconst POP_STATE = \"popstate\";\n/** 卸载之前beforeunload */\nconst BEFORE_UNLOAD = \"beforeunload\";\n/** readonly函数 */\nfunction readOnly(obj) {\n    return Object.freeze(obj);\n}\n/** warning函数 只告警 不抛Error */\nfunction warning(message) {\n    console.error(message);\n}\n/**\n * 处理浏览器url回撤跳转的情况，让浏览器弹出弹框提示用户\n * @param e\n */\nfunction handleBeforeUnload(e) {\n    e.preventDefault();\n    e.returnValue = \"\";\n}\n/**\n * createPath 解析Path对象 => path字符串\n * @param param0 Partial<Path>\n * @returns string\n */\nfunction createPath({ \n/** 需要给参数设置初始值，以保证获得一个完整的Path对象 */\npathname = \"/\", search = \"\", hash = \"\", }) {\n    let pathStr = pathname;\n    if (search) {\n        if (search?.startsWith(\"?\")) {\n            pathStr += search;\n        }\n        else {\n            pathStr += `?${search}`;\n        }\n    }\n    if (hash) {\n        if (hash?.startsWith(\"#\")) {\n            pathStr += hash;\n        }\n        else {\n            pathStr += `#${hash}`;\n        }\n    }\n    return pathStr;\n}\n/**\n * parsePath: 根据path路径 创建path对象\n * @param pathStr string\n * @returns Path\n */\nfunction parsePath(pathStr) {\n    const pathObj = { pathname: \"/\", hash: \"\", search: \"\" };\n    /** 从后向前解析 */\n    const hashIndex = pathStr.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        pathObj.hash = pathStr.slice(hashIndex);\n        pathStr = pathStr.slice(0, hashIndex);\n    }\n    const searchIndex = pathStr.indexOf(\"?\");\n    if (searchIndex >= 0) {\n        pathObj.search = pathStr.slice(searchIndex);\n        pathStr = pathStr.slice(0, searchIndex);\n    }\n    /** 赋值patiname */\n    pathObj.pathname = pathStr;\n    return pathObj;\n}\n/** 创建browser路由 */\nfunction createBrowserHistory({ window = document.defaultView } = {}) {\n    /** 获得window.history对象 其中可以存储location */\n    const globalHistory = window.history;\n    /** 获取当前的location 和 index */\n    function getCurrentLocationAndIndex() {\n        const { pathname, hash, search } = window.location;\n        const { state } = globalHistory;\n        return [\n            readOnly({\n                pathname,\n                hash,\n                search,\n                state: state?.usr || null,\n                key: state?.key || \"default\",\n            }),\n            state?.idx,\n        ];\n    }\n    /** 创建监听和block事件函数 */\n    const listener = new _EventCenter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    const blocker = new _EventCenter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    /** 获取当前的location和index 从当前window.location中取 */\n    let [location, index] = getCurrentLocationAndIndex();\n    /** 设置默认Action 初始为POP */\n    let action = Action.POP;\n    /** 如果index为undefined 说明当前页面还没有初始化过history对象\n     * 如果是页面刷新，当前的state里一定有idx\n     */\n    if (index === void 0) {\n        /** 初始化 idx赋 0 */\n        index = 0;\n        /** 使用replaceState在当前state里加入idx */\n        globalHistory.replaceState({\n            ...globalHistory.state,\n            idx: index,\n        }, \"\");\n    }\n    /**\n     * createHref方法 支持传入\n     * @param {to} To\n     * @returns href string\n     */\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    /**\n     * 生成下一个（新的 带插入的）Location对象\n     * @param to\n     * @param state\n     * @returns Location\n     */\n    function getNextLocation(to, state) {\n        /** 获得新的path */\n        const nextPath = typeof to === \"string\" ? parsePath(to) : to;\n        /** 以当前的pathname为base，生成location */\n        return readOnly({\n            pathname: window.location.pathname,\n            search: \"\",\n            hash: \"\",\n            ...nextPath,\n            state,\n            key: (0,_generateUniqueKey__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(),\n        });\n    }\n    /** 判断transition是否能执行 */\n    function allowTx(transition) {\n        return !blocker.length || blocker.call(transition) || false;\n    }\n    /** 应用 事务 变更内部状态 调用listener */\n    function applyTx(nextAction) {\n        action = nextAction;\n        /** 此时新的location已经被设置，需要调用listener 更新location和index状态 */\n        [location, index] = getCurrentLocationAndIndex();\n        listener.call({ location, action });\n    }\n    function getHistoryStateAndUrl(nextLocation, nextIndex) {\n        return [\n            readOnly({\n                usr: nextLocation.state,\n                key: nextLocation.key,\n                idx: nextIndex,\n            }),\n            /** nextLocation即成自Path 可以直接传 */\n            createHref(nextLocation),\n        ];\n    }\n    /**\n     * push方法\n     * @param to To\n     * @param state any\n     */\n    function push(to, state) {\n        /** 生成新的location */\n        const nextLocation = getNextLocation(to, state);\n        const retry = () => {\n            push(to, state);\n        };\n        /** 判断transiton是否允许 */\n        if (allowTx({ location: nextLocation, action: Action.PUSH, retry })) {\n            /** 把location转成存入globalHistory的state 以及URL */\n            const [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n            /** 保存到GlobalHistory */\n            globalHistory.pushState(historyState, \"\", url);\n            /**更新状态 调用listener */\n            applyTx(Action.PUSH);\n        }\n    }\n    /**\n     * replace\n     * @param to To\n     * @param state any\n     */\n    function replace(to, state) {\n        /** 生成新的location */\n        const nextLocation = getNextLocation(to, state);\n        const retry = () => {\n            push(to, state);\n        };\n        /** 判断transiton是否允许 */\n        if (allowTx({ location: nextLocation, action: Action.REPLACE, retry })) {\n            /** 把location转成存入globalHistory的state 以及URL */\n            const [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n            /** 保存到GlobalHistory */\n            globalHistory.replaceState(historyState, \"\", url);\n            /**更新状态 调用listener */\n            applyTx(Action.REPLACE);\n        }\n    }\n    function go(delta) {\n        globalHistory.go(delta);\n    }\n    /** 监听popstate 也就是监听go back forware 以及 浏览器前进后退*/\n    /** 其逻辑是，获取当前最新的location和index 并且封装一个retry go(delta)\n     *  由于POP_state事件监听到的时候，浏览器已经完成跳转了，所以如果allowTx为false的情况下，需要先将浏览器倒退\n     *  使用当前index - location.idx 算出浏览器这次POP到的位置和index的step\n     *   比如 浏览器向前pop 3步骤\n     *   假设当前index = 5\n     *   则location.idx = 8 此时index - location.idx = -3 那么需要先回退-3 执行blocker\n     *   同时封装retry为 go(-(index-location.idx)) 反向同理\n     */\n    let blockTx = null;\n    /** blockTx是个全局的transition 下面函数做的事情就是\n     * 1. 如果blockTx存在，则调用blocker，blocker中处理 在允许跳转之后需要unblock 再retry 否则可能死循环\n     * 2. 如果不存在blockTx 判断是否有blocker 如果有责创建blockTx 并且回退\n     */\n    window.addEventListener(POP_STATE, () => {\n        if (blockTx) {\n            // 运行blocker逻辑\n            blocker.call(blockTx);\n            blockTx = null;\n        }\n        else {\n            if (blocker.length > 0) {\n                /** 回退 */\n                const [nextLocation, nextIndex] = getCurrentLocationAndIndex();\n                if (nextIndex !== void 0) {\n                    const backDelta = index - nextIndex;\n                    blockTx = {\n                        location: nextLocation,\n                        action: Action.POP,\n                        retry: () => {\n                            go(-backDelta);\n                        },\n                    };\n                    // 回退 触发下一次popstate\n                    go(backDelta);\n                }\n                else {\n                    /** 我们知道 使用history时，state.idx 一定是由history中的 push/replace函数放入的 如果state.idx为空 则一定是手动调用pushState / repalcState */\n                    warning(\"请不要直接使用pushState / replaceState 操作路由！\");\n                }\n            }\n            else {\n                /** 更新状态 */\n                applyTx(Action.POP);\n            }\n        }\n    });\n    return {\n        action,\n        location,\n        createHref,\n        push,\n        replace,\n        go,\n        forward: () => {\n            go(1);\n        },\n        back: () => {\n            go(-1);\n        },\n        listen: (fn) => {\n            return listener.listen(fn);\n        },\n        block: (fn) => {\n            const unblock = blocker.listen(fn);\n            /** 需要处理跳转到站外的情况 url enter的情况 */\n            if (blocker?.length > 0) {\n                window.addEventListener(BEFORE_UNLOAD, handleBeforeUnload);\n            }\n            /** 返回unblock */\n            return () => {\n                unblock();\n                if (blocker.length === 0) {\n                    window.removeEventListener(BEFORE_UNLOAD, handleBeforeUnload);\n                }\n            };\n        },\n    };\n}\n/** 创建hash路由\n *  hash路由以 #/ 记录路由信息，其内容也包含 #/pathname?search#hash\n *  由于hash变动，不会导致浏览器重新请求资源，所以刷新页面的时候不会出现404问题，不需要后端设置默认index.html路径 / historyApiFallback\n */\nfunction createHashHistory({ window = document.defaultView }) {\n    const globalHistory = window.history;\n    /** 获得当前的Location和index  注意 这里需要从location.hash 获取 并且使用parsePath解析\n     *  hash模式下，由于真正的路由信息在# 后 所以浏览器不会自动解析好Path: {pathname,search,hash}\n     */\n    function getCurrentLocationAndIndex() {\n        /** 注意区别 这里是从location.hash取hash信息 并且自己Parse */\n        const hashStr = window.location.hash;\n        const state = globalHistory.state;\n        /** 这里注意 hashStr为 #/aaa 的形式 需要从第一个开始截取 */\n        const { pathname, search, hash } = parsePath(hashStr.slice(1));\n        return [\n            readOnly({\n                pathname,\n                search,\n                hash,\n                state: state?.usr,\n                key: state?.key\n            }),\n            state?.idx\n        ];\n    }\n    /**\n     * 获得下一个Location / 创建新的Location\n     * 传入to，state\n     */\n    function getNextLocation(to, state) {\n        const nextPath = typeof to === 'string' ? parsePath(to) : to;\n        return readOnly({\n            pathname: window.location.pathname,\n            search: '',\n            hash: '',\n            ...nextPath,\n            state,\n            key: (0,_generateUniqueKey__WEBPACK_IMPORTED_MODULE_1__[\"default\"])()\n        });\n    }\n    /**\n     * 这是一个和browser不同的地方\n     * 如果html文件的head中 包含<base> 标签，一般写法为:\n     *  <head>\n     *    <base href='/center/'>\n     *  ...</head>\n     * 当base包含属性href时，html中的 “相对” 路径计算，都会基于这个base的href\n     * 比如 <a href=\"./user\"/> 则 解析出来的地址 不是 http://example.com/user 而是 /center/user 这是一个绝对路径了 拼接上origin为http://example.com/center/user\n     *\n     * 在使用browser history时，由于history.pushState/repalceState时，都是传入一个绝对的url 也就是解析出来的path 所以base.href不起作用\n     * 但是，在使用hash router的时候，由于pushState/replaceState传入的路径是一个 #开头的字符串 即#/aaa/bbb/ccc 浏览器不会认为这是一个绝对路径，如果不存在base 则会将其加到当前路径下 http://example#/aaa/bbb/ccc\n     * 如果存在base 则会按照计算相对路径的方式 结合base生成一个绝对路径 即/center#/aaa/bbb/ccc => http://example/center#/aaa/bbb/ccc 就会凭空多出一个/center/\n     * 所以在这里就是 忽略base的影响，如果base标签存在 则直接返回一个绝对路径\n     */\n    function getBaseHref() {\n        const base = document.querySelector('base');\n        let baseHref = \"\";\n        if (base && base.href) {\n            const url = window.location.href;\n            const hashIndex = url.indexOf(\"#\");\n            baseHref = hashIndex >= 0 ? url.slice(0, hashIndex) : url;\n        }\n        return \"\";\n    }\n    /** 用来创建一个Href信息\n     *  用来生成url存入GlobalState中 或者生成一个可以被a使用的href信息\n     */\n    function createHref(to) {\n        /** 这里多了一个getBaseHref方法 和browser不同 */\n        return getBaseHref() + '#' + (typeof to === \"string\" ? to : createPath(to));\n    }\n    /** 获取GlobalHistory格式的state以及存入GlobalHistory的url */\n    function getHistoryStateAndUrl(location, index) {\n        return [\n            readOnly({\n                usr: location.search,\n                key: location.key,\n                idx: index\n            }),\n            createHref(location)\n        ];\n    }\n    /** 判断事务是否允许运行 */\n    function allowTx(tx) {\n        return !blocker?.length || (blocker.call(tx), false);\n    }\n    /** 应用事务 */\n    function applyTx(nextAction) {\n        action = nextAction;\n        /** 更新index和next */\n        [location, index] = getCurrentLocationAndIndex();\n        /** call listenener */\n        listener.call({ location, action });\n    }\n    /** 初始化Action 默认为Action.POP */\n    let action = Action.POP;\n    /** 获取index和location */\n    let [location, index] = getCurrentLocationAndIndex();\n    /** 创建listener和blocker事件中心 */\n    const listener = new _EventCenter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    const blocker = new _EventCenter__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    if (index === void 0) {\n        /** 不存在idx 初始化index */\n        index = 0;\n        /** replace idx到当前history.state中 */\n        globalHistory.replaceState({ ...globalHistory.state, idx: index }, \"\");\n    }\n    function push(to, state) {\n        const nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n        /** 是否允许事务 */\n        if (allowTx({ location: nextLocation, action: Action.PUSH, retry })) {\n            /** 生成HistoryState */\n            const [nextHistoryState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n            globalHistory.pushState(nextHistoryState, \"\", url);\n            /** 更改状态 */\n            applyTx(Action.PUSH);\n        }\n    }\n    function replace(to, state) {\n        const nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n        /** 是否允许事务 */\n        if (allowTx({ location: nextLocation, action: Action.REPLACE, retry })) {\n            /** 生成HistoryState */\n            const [nextHistoryState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\n            globalHistory.replaceState(nextHistoryState, \"\", url);\n            /** 更改状态 */\n            applyTx(Action.REPLACE);\n        }\n    }\n    /** GO */\n    function go(delta) {\n        globalHistory.go(delta);\n    }\n    /** 监听popstate函数 监听go 浏览器前进后退按钮事件 */\n    let blockTx = null;\n    window.addEventListener(POP_STATE, () => {\n        if (blockTx) {\n            /** 如果存在blockTx 直接调用blocker处理tx */\n            blocker.call(blockTx);\n            blockTx = null;\n        }\n        else {\n            /** 不存在blockTx */\n            if (blocker.length) {\n                /** 有阻塞 会退 设置blockTx */\n                /** 由于此时location已经修改完成 直接获取当前location和index即可 */\n                const [nextLocation, nextIndex] = getCurrentLocationAndIndex();\n                if (nextIndex !== void 0) {\n                    /** 计算会退step */\n                    const steps = index - nextIndex;\n                    /** 封装retry */\n                    function retry() {\n                        go(-steps);\n                    }\n                    /** 封装blockTx */\n                    blockTx = {\n                        location: nextLocation,\n                        action: Action.POP,\n                        retry\n                    };\n                    /** 回退 */\n                    go(steps);\n                }\n                else {\n                    warning(\"请不要绕过history调用 pushState/replaceState\");\n                }\n            }\n            else {\n                /** 没有阻塞 应用tx */\n                applyTx(Action.POP);\n            }\n        }\n    });\n    return {\n        action,\n        location,\n        push,\n        replace,\n        createHref,\n        go,\n        back: () => { go(-1); },\n        forward: () => { go(1); },\n        listen: (fn) => {\n            return listener.listen(fn);\n        },\n        block: (fn) => {\n            const unblock = blocker.listen(fn);\n            if (blocker.length > 0) {\n                window.addEventListener(BEFORE_UNLOAD, handleBeforeUnload);\n            }\n            return () => {\n                unblock();\n                if (blocker.length === 0) {\n                    window.removeEventListener(BEFORE_UNLOAD, handleBeforeUnload);\n                }\n            };\n        }\n    };\n}\n\n\n//# sourceURL=webpack://my-sample-history/./src/libs/index.ts?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/libs/index.ts");
/******/ var __webpack_exports__Action = __webpack_exports__.Action;
/******/ var __webpack_exports__createBrowserHistory = __webpack_exports__.createBrowserHistory;
/******/ var __webpack_exports__createHashHistory = __webpack_exports__.createHashHistory;
/******/ export { __webpack_exports__Action as Action, __webpack_exports__createBrowserHistory as createBrowserHistory, __webpack_exports__createHashHistory as createHashHistory };
/******/ 
